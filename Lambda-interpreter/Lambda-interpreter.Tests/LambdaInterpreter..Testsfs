module LambdaInterpreter.Tests

open NUnit.Framework
open Interpreter 

[<Test>]
let ``Substitute id`` () =
    let expr = Abstraction ("x", Var "x")
    let s = Var "y"
    let result = substitute "x" s expr
    Assert.That(expr, Is.EqualTo(result))

[<Test>]
let ``aConversionTest`` () =
    let expr = Abstraction ("x", Application(Var "x", Var "y"))
    let result = aConversionAndReplace "x" "z" expr
    let expected = Abstraction( "z", Application(Var "z", Var "y") )
    Assert.That(expected, Is.EqualTo(result))

[<Test>]
let ``SubstituteTest`` () =
    let expr = Abstraction ("x", Abstraction ("y", Application (Var "x", Var "y")))
    let s = Var "y"
    let result = substitute "x" s expr
    match result with
    | Abstraction (z, Abstraction (y2, body)) ->
        Assert.That("x", Is.EqualTo(z))
        Assert.That("y", Is.EqualTo(y2))
    | _ -> Assert.Fail("Unexpected structure")

[<Test>]
let ``ReduceRedex`` () =
    let expr = Application (Abstraction ("x", Var "x"), Var "y")
    let reduced = reduceNormal expr
    Assert.That(Var "y", Is.EqualTo(reduced))

[<Test>]
let ``Reduce twice application`` () =
    let id = Abstraction ("x", Var "x")
    let expr = Application (Abstraction ("x", Application (Var "x", Var "x")), id)
    let reduced = reduceNormal expr
    match reduced with
    | Abstraction (x, a) ->
        Assert.That(x, Is.EqualTo("x"))
        Assert.That(Var "x", Is.EqualTo(a))
    | _ -> Assert.Fail("Unexpected structure")

[<Test>]
let bReduceNormal() =
    let expr = 
        Application(
            Abstraction("x", Abstraction("y", Application(Var "x", Var "y"))),
            Var "y"
        )
    
    let result = reduceNormal expr

    match result with
    | Abstraction(newVar, Application(Var v1, Var v2)) ->
        Assert.That("x0", Is.EqualTo(newVar))
        Assert.That("y", Is.EqualTo(v1))
        Assert.That("x0", Is.EqualTo(v2))
    | _ -> Assert.Fail()